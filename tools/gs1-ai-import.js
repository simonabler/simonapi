#!/usr/bin/env node
/**
 * Import GS1 AI definitions (JSON) and regenerate the TypeScript registry.
 *
 * Usage:
 *   node tools/gs1-ai-import.js path/to/gs1-ais.json
 *
 * Expected JSON shape (array of items). It tries to auto-detect fields:
 *   [ { ai: "01", label: "GTIN", pattern: "^\\d{14}$", requiresOneOf?: ["..."], notTogetherWith?: ["..."], maxOccurrences?: 1 } ]
 * Alternatively supports keys: title/name for label, regexp/regex for pattern.
 */
const fs = require('fs');
const path = require('path');

function loadJson(p) {
  const raw = fs.readFileSync(p, 'utf-8');
  return JSON.parse(raw);
}

function normalizeItem(x) {
  // Allow JSON-LD shape
  const aiCode = x.applicationIdentifier || x.ai || x.AI || x.id;
  const ai = aiCode ? String(aiCode).trim() : '';
  if (!ai) return null;
  const label = String(x.label || x.title || x.name || '').trim() || ai;
  const patStr = String(x.pattern || x.regexp || x.regex || '').trim();
  if (!patStr) return null;
  // Strip surrounding slashes if present
  const src = patStr.replace(/^\/(.*)\/[a-z]*$/i, '$1');
  // Utilities to expand AI lists (supports ranges with {start,end})
  const expandList = (arr) => {
    const out = [];
    for (const e of arr) {
      if (typeof e === 'string') out.push(String(e));
      else if (Array.isArray(e)) out.push(...e.map(String));
      else if (e && typeof e === 'object' && e.start && e.end) {
        const s = String(e.start);
        const t = String(e.end);
        const pad = s.length;
        const n1 = parseInt(s, 10);
        const n2 = parseInt(t, 10);
        if (!Number.isNaN(n1) && !Number.isNaN(n2) && n2 >= n1) {
          for (let n = n1; n <= n2; n++) {
            out.push(String(n).padStart(pad, '0'));
          }
        }
      }
    }
    return Array.from(new Set(out));
  };

  // Map requires: may be string, array of strings, array of arrays, or include ranges
  let requiresGroups = undefined;
  const req = x.requiresOneOf || x.requires;
  if (req) {
    if (Array.isArray(req)) {
      if (req.length && Array.isArray(req[0])) {
        // array of groups
        requiresGroups = req.map(g => expandList(g));
      } else {
        requiresGroups = [expandList(req)];
      }
    } else if (typeof req === 'string') {
      requiresGroups = [[String(req)]];
    }
  }
  // Flatten requires into requiresOneOf (union) for convenience
  let requiresOneOf = undefined;
  if (requiresGroups) {
    const set = new Set();
    for (const g of requiresGroups) for (const a of g) set.add(String(a));
    requiresOneOf = Array.from(set);
  }
  const excl = x.notTogetherWith || x.excludes;
  return {
    ai,
    label,
    pattern: src,
    requiresOneOf,
    requiresGroups,
    notTogetherWith: Array.isArray(excl) ? expandList(excl) : undefined,
    maxOccurrences: x.maxOccurrences || x.maxOccurs || undefined,
    hint: x.hint || x.note || undefined,
  };
}

function emitTs(items) {
  const header = `// Auto-generated by tools/gs1-ai-import.js\n` +
    `// Source: ref.gs1.org (via provided JSON export)\n\n` +
    `export type AiRegexSpec = {\n` +
    `  ai: string;\n  label: string;\n  pattern: RegExp;\n  maxOccurrences?: number;\n  requiresOneOf?: string[];\n  requiresGroups?: string[][];\n  notTogetherWith?: string[];\n  hint?: string;\n};\n\n` +
    `function re(rx: string, flags?: string): RegExp {\n` +
    `  const a = rx.startsWith('^') ? rx : '^' + rx;\n` +
    `  const b = a.endsWith('$') ? a : a + '$';\n` +
    `  return new RegExp(b, flags);\n` +
    `}\n\n`;
  const entries = items.map(it => {
    const props = [
      `ai: '${it.ai}'`,
      `label: ${JSON.stringify(it.label)}`,
      `pattern: re(${JSON.stringify(it.pattern)})`,
      it.maxOccurrences ? `maxOccurrences: ${it.maxOccurrences}` : null,
      it.requiresOneOf ? `requiresOneOf: ${JSON.stringify(it.requiresOneOf)}` : null,
      it.requiresGroups ? `requiresGroups: ${JSON.stringify(it.requiresGroups)}` : null,
      it.notTogetherWith ? `notTogetherWith: ${JSON.stringify(it.notTogetherWith)}` : null,
      it.hint ? `hint: ${JSON.stringify(it.hint)}` : null,
    ].filter(Boolean).join(', ');
    return `  '${it.ai}': { ${props} }`;
  }).join(',\n');

  const body = `export const AI_REGEX_DB: Record<string, AiRegexSpec> = {\n${entries}\n};\n\n` +
  `export type Gs1CombinationRule =\n  | { type: 'requiresOneOf'; ai: string; requires: string[] }\n  | { type: 'mutuallyExclusive'; aiList: string[] }\n  | { type: 'unique'; ai: string };\n\n` +
  `export const COMBINATION_RULES: Gs1CombinationRule[] = [];\n\n` +
  `export function getAiSpec(ai: string): AiRegexSpec | undefined {\n  return AI_REGEX_DB[ai];\n}\n\n` +
  `export function validateAiByRegex(ai: string, value: string): void {\n  const spec = getAiSpec(ai);\n  if (!spec) throw new Error(\`AI \${ai} not supported\`);\n  if (!spec.pattern.test(value)) throw new Error(\`AI \${ai} value does not match required pattern\`);\n}\n\n` +
  `export function validateCombination(items: Array<{ ai: string; value: string }>): void {\n  const counts = new Map<string, number>();\n  for (const it of items) { counts.set(it.ai, (counts.get(it.ai) || 0) + 1); }\n  // Per-AI constraints from registry\n  for (const [ai, cnt] of counts) {\n    const spec = getAiSpec(ai);\n    const max = spec?.maxOccurrences ?? 1;\n    if (cnt > max) throw new Error(\`AI \${ai} occurs \${cnt} times (max \${max})\`);\n  }\n  for (const [ai] of counts) {\n    const spec = getAiSpec(ai);\n    if (!spec) continue;\n    if (spec.notTogetherWith) {\n      const conflict = spec.notTogetherWith.filter(a => (counts.get(a) || 0) > 0);\n      if (conflict.length) throw new Error(\`AI \${ai} not allowed with: \${conflict.join(', ')}\`);\n    }\n    if (spec.requiresOneOf && spec.requiresOneOf.length) {\n      const ok = spec.requiresOneOf.some(a => (counts.get(a) || 0) > 0);\n      if (!ok) throw new Error(\`AI \${ai} requires one of [\${spec.requiresOneOf.join(', ')}]\`);\n    }\n    if (spec.requiresGroups && spec.requiresGroups.length) {\n      for (const group of spec.requiresGroups) {\n        const ok = group.some(a => (counts.get(a) || 0) > 0);\n        if (!ok) throw new Error(\`AI \${ai} requires one of group [\${group.join(', ')}]\`);\n      }\n    }\n  }\n  // Additional project-wide rules may be added here\n}\n`;
  return header + body;
}

function main() {
  const inPath = process.argv[2];
  if (!inPath) {
    console.error('Usage: node tools/gs1-ai-import.js <path-to-json>');
    process.exit(1);
  }
  const src = loadJson(inPath);
  let arr = src;
  if (!Array.isArray(arr)) {
    // Try JSON-LD shape
    if (src && Array.isArray(src.applicationIdentifiers)) {
      arr = src.applicationIdentifiers.filter(it => it && it.applicationIdentifier);
    } else {
      console.error('Expected a JSON array or JSON-LD with applicationIdentifiers[]');
      process.exit(1);
    }
  }
  const mapped = arr.map(normalizeItem).filter(Boolean);
  if (!mapped.length) {
    console.error('No valid items found in provided JSON');
    process.exit(1);
  }
  const out = emitTs(mapped);
  const outPath = path.resolve('apps/server/src/app/barcode/gs1-ai-registry.ts');
  fs.writeFileSync(outPath, out);
  console.log(`Wrote ${mapped.length} AIs to ${outPath}`);
}

if (require.main === module) main();
